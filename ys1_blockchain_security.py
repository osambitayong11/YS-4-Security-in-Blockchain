# -*- coding: utf-8 -*-
"""YS1-Blockchain-Security.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10IZWNC1BGfkc1v55HCuG4W0ynCEU_VPj

# Vulnerable and Outdated Components

<p>Vulnerable and outdated components refer to software libraries, frameworks, or other components that have known security vulnerabilities or are no longer supported or updated by their creators. These components pose a risk to the applications and systems that use them, as attackers can exploit the known vulnerabilities to gain unauthorized access, execute malicious code, or compromise sensitive data.</p>

<p>To prevent the risks associated with vulnerable and outdated components, developers should:

<ul>1. Keep track of the components used in their projects and their versions.</ul>
<ul>2. Regularly update components to the latest stable versions.</ul>
<ul>3. Remove unused components from the project.</ul>
<ul>4. Monitor security advisories and vulnerability databases to stay informed about potential issues in the components they use.</ul>
<ul>5. Consider using tools to automatically detect vulnerable dependencies.</ul>
<ul>6. By following these practices, developers can reduce the risk associated with using vulnerable and outdated components in their web applications.</ul>
</p>

<p>Examples of vulnerable and outdated components can be found across various programming languages and ecosystems. Some common examples include:

<ul>1. OpenSSL Heartbleed Vulnerability (CVE-2014-0160): In 2014, a critical vulnerability was discovered in OpenSSL, a widely-used cryptographic library. The vulnerability, known as Heartbleed, allowed attackers to read sensitive data from the memory of servers using affected OpenSSL versions. Many applications and systems had to be patched or updated to use a secure version of OpenSSL.</ul>

<ul>2. Apache Struts 2 Remote Code Execution Vulnerability (CVE-2017-5638): This vulnerability affected the Apache Struts 2 web application framework, which is used by many Java-based web applications. The flaw allowed attackers to execute arbitrary code on affected systems, potentially leading to data breaches or server compromise. Developers had to update their Struts 2 installations to a secure version to mitigate the risk.</ul>

<ul>3. jQuery File Upload Vulnerability (CVE-2018-9206): This vulnerability affected the popular jQuery File Upload plugin, which is widely used for file uploads in web applications. The flaw allowed attackers to upload arbitrary files, including malicious scripts, to affected servers. Developers using the plugin had to update to a secure version or implement additional security measures.</ul>

<ul>4. Apache Log4j 2 Vulnerability (CVE-2021-44228): Also known as "Log4Shell," this vulnerability affected the widely-used Log4j 2 logging library for Java applications. The flaw allowed attackers to execute arbitrary code on affected systems by exploiting a feature in the library. Developers had to update their Log4j 2 installations to a secure version or apply workarounds to mitigate the risk.</ul>

<ul>5. These examples illustrate the importance of keeping components up-to-date and monitoring security advisories. Using vulnerable and outdated components can expose applications and systems to significant risks, potentially leading to data breaches, unauthorized access, or other security incidents.</ul>
</p>


<p><h2>"51% Attack"</h2>

The "51% attack" or "double-spending attack" on a Proof-of-Work (PoW) blockchain, such as Bitcoin and Ethereum Classic. This attack highlights the importance of maintaining a decentralized and secure network.

In a PoW blockchain, miners compete to solve complex cryptographic puzzles to add a new block to the blockchain. The security of the network relies on the assumption that no single miner or group of miners controls more than 50% of the total hashing power. If a malicious actor manages to control the majority of the network's hashing power, they could potentially manipulate the blockchain in their favor.

<h3>Consequence:</h3>

<li>Double spending: The attacker can spend their cryptocurrency more than once by reversing their own transactions. They can first spend their coins in a transaction, then secretly mine a longer chain of blocks that omits that transaction, effectively erasing it and allowing them to spend the same coins again.

<li>Censorship: The attacker can choose to not include certain transactions in the blocks they mine, effectively censoring those transactions and preventing them from being processed by the network.

<li>Loss of confidence: A successful 51% attack can undermine the trust in the affected blockchain, causing its value to plummet and users to lose confidence in the network's security.

<h3>Solutions for a 51% attack:</h3>

<li>Increasing network participation: Encouraging more miners to participate in the network can help distribute the hashing power more evenly, making it harder for any single entity to gain control.

<li>Changing the consensus algorithm: Switching from a PoW-based consensus mechanism to alternatives such as Proof-of-Stake (PoS) or Delegated Proof-of-Stake (DPoS) can make it more difficult for an attacker to amass enough resources to control the network.

<li>Implementing checkpointing: By periodically committing a block hash to a more secure and established blockchain, it becomes harder for an attacker to create an alternative chain that can overtake the legitimate one.

It's important to note that not all blockchains are equally vulnerable to 51% attacks. The larger and more decentralized a network is, the more secure it becomes against such threats.</p>

# Cryptographic Failures

<p>Cryptographic failures refer to the improper implementation, configuration, or usage of cryptographic algorithms and protocols in a web application. These failures can lead to the exposure of sensitive information and unauthorized access to the system, putting user data and the application's integrity at risk.

Some common cryptographic failures include:

<ul>1. Using weak or outdated cryptographic algorithms: Employing algorithms with known weaknesses or those that have been deprecated by security standards may make it easier for attackers to break the encryption.</ul>
<ul>2. Insufficient key management: Failing to securely generate, store, and manage cryptographic keys can lead to unauthorized access or the compromise of sensitive data.</ul>
<ul>3. Insecure random number generation: Using predictable or insecure random number generators can make cryptographic processes more vulnerable to attacks.</ul>
<ul>4. Not enforcing secure communication: Failing to enforce encrypted communication channels, such as HTTPS, can expose sensitive data to eavesdropping attacks.</ul>
<ul>5. Inadequate protection of sensitive data: Failing to encrypt sensitive data at rest or in transit can make it more accessible to attackers.</ul>
</p>

<p>In blockchain technology, cryptographic failures can have severe consequences as they may lead to the compromise of sensitive data, unauthorized access, or even loss of funds. Here are some examples of cryptographic failures in the blockchain space:</p>

<ul>1. Weak or outdated cryptographic algorithms:
Some early blockchain projects utilized cryptographic algorithms that have since been found to be weak or deprecated. For instance, Bitcoin initially used the SHA-1 hashing algorithm for certain operations, which has since been shown to have vulnerabilities. Bitcoin later transitioned to using the more secure SHA-256 algorithm.</ul>

<ul>2. Insufficient key management:
Private keys are critical for accessing and managing blockchain assets. If a user fails to securely store or manage their private keys, an attacker could potentially gain access to their funds. Examples of insufficient key management include storing private keys in plain text, using weak passwords, or not using hardware wallets for cold storage.</ul>

<ul>3. Insecure random number generation:
In 2013, a vulnerability was discovered in the random number generation process of the Android operating system. This flaw led to the generation of weak and predictable private keys for some Bitcoin wallets, making them vulnerable to theft. Users who had created Bitcoin wallets using affected Android devices had their funds stolen by attackers.</ul>

<ul>4. Smart contract vulnerabilities:
Cryptographic failures can also occur within smart contracts, which are self-executing contracts with the terms of the agreement directly written into code. Examples include the 2016 DAO (Decentralized Autonomous Organization) hack on the Ethereum network, where a flaw in the smart contract's code allowed an attacker to drain millions of dollars' worth of Ether.</ul>

<ul>5. Replay attacks:
During the Ethereum Classic (ETC) and Ethereum (ETH) hard fork in 2016, some users experienced a replay attack due to a lack of replay protection. Transactions on one chain could be "replayed" on the other chain, leading to potential double-spends or unintended fund transfers.</ul>

<ul>6. To avoid cryptographic failures in the blockchain space, it is crucial to adhere to best practices, such as using secure cryptographic algorithms, managing private keys securely, employing secure random number generation, and thoroughly auditing smart contracts for vulnerabilities. Additionally, staying up-to-date with the latest research and developments in cryptography and blockchain security is essential to mitigate potential risks.</ul>

<ul>7. In conclusion, cryptographic failures are related to the improper handling of cryptographic processes in a web application, which can lead to the compromise of sensitive data and unauthorized access. To mitigate these risks, developers should adhere to best practices in cryptography, ensure secure communication, and keep their software components up-to-date.</ul>

Let's consider an example of a simple Python script that generates an Ethereum private key and its corresponding public key using an insecure random number generator from the random module. This approach would be considered a cryptographic failure, as the private key could be predicted by an attacker who knows the seed value.

Here's an example of generating an Ethereum key pair using the insecure random module:
"""

import random
import ecdsa
from eth_utils import keccak, to_checksum_address

def generate_ethereum_keypair_insecure():
    # Insecure random number generator
    private_key = random.randint(1, ecdsa.SECP256k1.order - 1)
    public_key = ecdsa.SigningKey.from_secret_exponent(private_key, curve=ecdsa.SECP256k1).verifying_key.to_string()
    eth_address = keccak(public_key[1:], digest_size=20).hex()
    
    return (hex(private_key), to_checksum_address(eth_address))

insecure_keypair = generate_ethereum_keypair_insecure()
print("Private Key:", insecure_keypair[0])
print("Address:", insecure_keypair[1])

"""The above code generates an Ethereum private key using an insecure random number generator from the random module, which is not suitable for cryptographic purposes.

To fix this issue, we can use the secrets module to generate a cryptographically secure random number for the private key:

In the updated code, we use the secrets.randbelow function to generate a cryptographically secure random number for the Ethereum private key. This ensures that the generated private key is unpredictable and secure.

In summary, when working with blockchain-related cryptography in Python, it's crucial to use cryptographically secure random number generators like the ones provided by the secrets module, rather than relying on the insecure random module.
"""

import secrets
import ecdsa
from eth_utils import keccak, to_checksum_address

def generate_ethereum_keypair_secure():
    # Cryptographically secure random number generator
    private_key = secrets.randbelow(ecdsa.SECP256k1.order - 1) + 1
    public_key = ecdsa.SigningKey.from_secret_exponent(private_key, curve=ecdsa.SECP256k1).verifying_key.to_string()
    eth_address = keccak(public_key[1:], digest_size=20).hex()
    
    return (hex(private_key), to_checksum_address(eth_address))

secure_keypair = generate_ethereum_keypair_secure()
print("Private Key:", secure_keypair[0])
print("Address:", secure_keypair[1])

"""# Injection

<p>According to the 2021 OWASP Top Ten, injection is a security vulnerability that occurs when untrusted data is sent to an interpreter as part of a command or query, allowing an attacker to execute unauthorized commands or access sensitive data. Injection attacks can occur in a variety of contexts, such as SQL, NoSQL, OS, and LDAP queries.</p>

<p>Injection vulnerabilities occur when untrusted data is not properly sanitized or validated before being used in a command or query, allowing an attacker to inject malicious code or manipulate the query to obtain unauthorized access to sensitive data. Common examples of injection attacks include SQL injection, command injection, and LDAP injection.</p>

<p>The impact of injection attacks can be severe, as an attacker can potentially gain complete control over the system or access sensitive data, such as passwords or financial information. Therefore, it is important to use input validation and parameterized queries to prevent injection attacks and ensure the security of the system.</p>

<p>The best way to prevent an injection attack is by creating a safe API to interact with the database without using an interpreter. Other ways to prevent injection attacks are positive server-side data validation and the use of LIMIT or other SQL controls to prevent large disclosures of records.</p>
"""

import mysql.connector
import sys

def get_user_data(username):
    query = "SELECT * FROM users WHERE username = '" + username + "';"
    cnx = mysql.connector.connect(user='root', password='password',
                              host='127.0.0.1',
                              database='mydb')
    cursor = cnx.cursor()
    cursor.execute(query)
    data = cursor.fetchall()
    cursor.close()
    cnx.close()
    return data

if __name__ == "__main__":
    username = sys.argv[1]
    data = get_user_data(username)
    print(data)

"""In the above code, the get_user_data function retrieves user data from a MySQL database based on the provided username argument. However, the SQL query is constructed by concatenating the username argument directly to the query string, making it vulnerable to SQL injection attacks.

An attacker can exploit this vulnerability by injecting malicious SQL code as the username argument, allowing them to execute arbitrary SQL commands or access sensitive data.

To prevent SQL injection vulnerabilities, we should use parameterized queries or prepared statements, which separate the SQL code from the user input and provide automatic sanitization of input data. Here's an example of the same code using parameterized queries:
"""

import mysql.connector
import sys

def get_user_data(username):
    query = "SELECT * FROM users WHERE username = %s;"
    cnx = mysql.connector.connect(user='root', password='password',
                              host='127.0.0.1',
                              database='mydb')
    cursor = cnx.cursor()
    cursor.execute(query, (username,))
    data = cursor.fetchall()
    cursor.close()
    cnx.close()
    return data

if __name__ == "__main__":
    username = sys.argv[1]
    data = get_user_data(username)
    print(data)

"""In the above code, we use a parameterized query with a single '%s' placeholder for the username argument. The cursor.execute function automatically sanitizes the input data, preventing SQL injection attacks.

# Indetification and Authentication Failures

The example below is an example of a smart contract in Solidity. There is a function to deposit and withdraw money from the selected account. Based on this example, anyone is able to deposit money into the account without proper authorization. The withdraw function only checks if they requested amount is available in the account. The smart contract below has no authentication such as Role-based Access Control (RBAC) and Multi-Factor Authentication (MFA).
"""

pragma solidity ^0.8.0;

contract AuthenticationExample {
    mapping(address => uint) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        msg.sender.transfer(amount);
        balances[msg.sender] -= amount;
    }
}

"""Multi-Factor Authentication (MFA) Solution"""

pragma solidity ^0.8.0;

contract AuthenticationExample {
    mapping(address => uint) public balances;
    mapping(address => bool) public authorized;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount, uint code) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        require(authorized[msg.sender], "Not authorized");
        require(verifyCode(code), "Invalid code");
        msg.sender.transfer(amount);
        balances[msg.sender] -= amount;
    }

    function authorize(address user, uint code) public {
        require(verifyCode(code), "Invalid code");
        authorized[user] = true;
    }

    function deauthorize(address user, uint code) public {
        require(verifyCode(code), "Invalid code");
        authorized[user] = false;
    }

    function verifyCode(uint code) private view returns(bool) {
        // Code verification logic here
        return true;
    }
}

"""Role-based Access Control Solution"""

pragma solidity ^0.8.0;

contract AuthenticationExample {
    mapping(address => uint) public balances;
    mapping(address => uint8) public roles;

    uint8 constant ROLE_USER = 0;
    uint8 constant ROLE_ADMIN = 1;

    modifier onlyAdmin() {
        require(roles[msg.sender] == ROLE_ADMIN, "Only admin can call this function");
        _;
    }

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        require(roles[msg.sender] == ROLE_USER || roles[msg.sender] == ROLE_ADMIN, "Not authorized");
        msg.sender.transfer(amount);
        balances[msg.sender] -= amount;
    }

    function grantAdminRole(address user) public onlyAdmin {
        roles[user] = ROLE_ADMIN;
    }

    function revokeAdminRole(address user) public onlyAdmin {
        roles[user] = ROLE_USER;
    }
}

"""# Security Logging and Monitoring Failures

Security logging is the practice of generating, recording, and analyzing log events to detect and respond to security incidents. Security logging provides visibility into the system's behavior and helps identify and investigate security incidents, making it an essential part of a security program.

Security logging involves collecting and analyzing various types of logs, including system logs, application logs, network logs, and security logs. These logs contain valuable information about user activity, system events, and security-related incidents that can help identify security threats and vulnerabilities.

Effective security logging practices include the following:

*   Collecting all relevant logs: Collect logs from all relevant sources, including servers, applications, network devices, and security systems.
*   Analyzing logs in real-time: Analyze logs in real-time to detect and respond to security incidents quickly.
*   Storing logs securely: Store logs securely in a centralized location that is protected from unauthorized access or tampering.
*   Retaining logs for a sufficient period: Retain logs for a sufficient period to comply with regulatory requirements and allow for historical analysis.
*   Generating alerts: Configure alerts to notify security teams of potential security incidents.
*   Regularly reviewing logs: Regularly review logs to identify potential security threats or vulnerabilities.

By implementing security logging practices, organizations can gain better visibility into their systems' behavior, detect and respond to security incidents quickly, and improve their overall security posture.
"""

import logging

def login(username, password):
    # check if username and password are correct
    if username == "admin" and password == "password":
        logging.info("Successful login for user {}".format(username))
        return True
    else:
        logging.warning("Failed login attempt for user {}".format(username))
        return False

if __name__ == "__main__":
    username = input("Enter username: ")
    password = input("Enter password: ")
    login(username, password)

"""In the above code, the login function logs a message using the Python logging module when a user successfully logs in or fails to log in. However, the logging messages do not provide sufficient detail to help investigate security incidents or detect potential attacks. For example, the logging messages do not include information such as the source IP address, the timestamp, or the type of attack attempted.

A more secure implementation of the login function would be to include additional information in the logging messages, such as the user's IP address and the type of authentication attempted. Here's an example of a more secure implementation:
"""

import logging

def login(username, password, ip_address):
    # check if username and password are correct
    if username == "admin" and password == "password":
        logging.info("Successful login for user {} from IP address {}".format(username, ip_address))
        return True
    else:
        logging.warning("Failed login attempt for user {} from IP address {}".format(username, ip_address))
        return False

if __name__ == "__main__":
    username = input("Enter username: ")
    password = input("Enter password: ")
    ip_address = input("Enter IP address: ")
    login(username, password, ip_address)

"""In the above code, the login function includes the user's IP address in the logging messages, providing more information to help investigate security incidents or detect potential attacks. It's important to note that security logging is just one aspect of a comprehensive security program and should be used in conjunction with other security controls, such as access control, encryption, and vulnerability management."""